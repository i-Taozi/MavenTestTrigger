package net.ttddyy.dsproxy.proxy;

import net.ttddyy.dsproxy.ConnectionInfo;
import net.ttddyy.dsproxy.listener.CallCheckMethodExecutionListener;
import net.ttddyy.dsproxy.listener.MethodExecutionContext;
import net.ttddyy.dsproxy.listener.MethodExecutionListener;
import net.ttddyy.dsproxy.listener.QueryExecutionListener;
import net.ttddyy.dsproxy.proxy.jdk.PreparedStatementInvocationHandler;
import net.ttddyy.dsproxy.proxy.jdk.StatementInvocationHandler;
import org.junit.Test;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.concurrent.atomic.AtomicBoolean;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @author Tadaya Tsuyukubo
 */
public class ConnectionProxyLogicMockTest {

    @Test
    public void testCreateStatementWithNoParam() throws Throwable {
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);

        Method method = Connection.class.getMethod("createStatement");
        Object result = logic.invoke(conn, method, new Object[]{});

        assertThat(result).isInstanceOf(Statement.class);
        verifyStatement((Statement) result);
        verify(conn).createStatement();
    }

    @Test
    public void testCreateStatementWithTwoParam() throws Throwable {
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);


        Method method = Connection.class.getMethod("createStatement", int.class, int.class);
        Object result = logic.invoke(conn, method, new Object[]{ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY});

        assertThat(result).isInstanceOf(Statement.class);
        verifyStatement((Statement) result);
        verify(conn).createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
    }

    @Test
    public void testCreateStatementWithThreeParam() throws Throwable {
        // expect
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);

        // run
        Method method = Connection.class.getMethod("createStatement", int.class, int.class, int.class);
        Object result = logic.invoke(conn, method, new Object[]{ResultSet.TYPE_FORWARD_ONLY,
                ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT});

        // verify
        assertThat(result).isInstanceOf(Statement.class);
        verifyStatement((Statement) result);

        verify(conn).createStatement(ResultSet.TYPE_FORWARD_ONLY,
                ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    private ConnectionProxyLogic getProxyLogic(Connection mockConnection) {
        QueryExecutionListener listener = mock(QueryExecutionListener.class);

        ConnectionInfo connectionInfo = new ConnectionInfo();
        connectionInfo.setDataSourceName("myDS");

        ProxyConfig proxyConfig = ProxyConfig.Builder.create().queryListener(listener).build();
        return new ConnectionProxyLogic(mockConnection, connectionInfo, proxyConfig);
    }

    private void verifyStatement(Statement statement) {
        assertThat(statement).isNotNull();

        assertThat(Proxy.isProxyClass(statement.getClass())).isTrue();
        InvocationHandler handler = Proxy.getInvocationHandler(statement);
        assertThat(handler).isInstanceOf(StatementInvocationHandler.class);
    }


    @Test
    public void testPrepareStatement() throws Throwable {
        // expect
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);

        String query = "select * from emp";

        // run
        Method method = Connection.class.getMethod("prepareStatement", String.class);
        Object result = logic.invoke(conn, method, new Object[]{query});

        // verify
        assertThat(result).isInstanceOf(PreparedStatement.class);
        verifyPreparedStatement((PreparedStatement) result);
    }

    @Test
    public void testPrepareStatementWithAutoGeneratedKeys() throws Throwable {
        // expect
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);

        String query = "select * from emp";

        // run
        Method method = Connection.class.getMethod("prepareStatement", String.class, int.class);
        Object result = logic.invoke(conn, method, new Object[]{query, Statement.RETURN_GENERATED_KEYS});

        // verify
        assertThat(result).isInstanceOf(PreparedStatement.class);
        verifyPreparedStatement((PreparedStatement) result);
        verify(conn).prepareStatement(query, Statement.RETURN_GENERATED_KEYS);
    }

    @Test
    public void testPrepareStatementWithColumnIndexes() throws Throwable {
        // expect
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);

        String query = "select * from emp";
        int[] columnIndexes = new int[]{1, 2, 3};

        // run
        Method method = Connection.class.getMethod("prepareStatement", String.class, int[].class);
        Object result = logic.invoke(conn, method, new Object[]{query, columnIndexes});

        // verify
        assertThat(result).isInstanceOf(PreparedStatement.class);
        verifyPreparedStatement((PreparedStatement) result);
        verify(conn).prepareStatement(query, columnIndexes);
    }

    @Test
    public void testPrepareStatementWithColumnNames() throws Throwable {
        // expect
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);

        String query = "select * from emp";
        String[] columnNames = new String[]{"id", "name"};

        // run
        Method method = Connection.class.getMethod("prepareStatement", String.class, String[].class);
        Object result = logic.invoke(conn, method, new Object[]{query, columnNames});

        // verify
        assertThat(result).isInstanceOf(PreparedStatement.class);
        verifyPreparedStatement((PreparedStatement) result);
        verify(conn).prepareStatement(query, columnNames);
    }

    @Test
    public void testPrepareStatementWithTwoResultSetParams() throws Throwable {
        // expect
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);

        String query = "select * from emp";

        // run
        Method method = Connection.class.getMethod("prepareStatement", String.class, int.class, int.class);
        Object result = logic.invoke(conn, method, new Object[]{query,
                ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY});


        // verify
        assertThat(result).isInstanceOf(PreparedStatement.class);
        verifyPreparedStatement((PreparedStatement) result);
        verify(conn).prepareStatement(query,
                ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
    }

    @Test
    public void testPrepareStatementWithThreeResultSetParams() throws Throwable {
        // expect
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);

        String query = "select * from emp";

        // run
        Method method = Connection.class.getMethod("prepareStatement", String.class, int.class, int.class, int.class);
        Object result = logic.invoke(conn, method, new Object[]{query,
                ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT});

        // verify
        assertThat(result).isInstanceOf(PreparedStatement.class);
        verifyPreparedStatement((PreparedStatement) result);
        verify(conn).prepareStatement(query,
                ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    private void verifyPreparedStatement(PreparedStatement statement) {
        assertThat(statement).isNotNull();

        assertThat(Proxy.isProxyClass(statement.getClass())).isTrue();
        InvocationHandler handler = Proxy.getInvocationHandler(statement);
        assertThat(handler).isInstanceOf(PreparedStatementInvocationHandler.class);
    }


    @Test
    public void testGetTarget() throws Throwable {
        Connection orig = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(orig);

        // run
        Method method = ProxyJdbcObject.class.getMethod("getTarget");
        Object result = logic.invoke(orig, method, null);

        assertThat(result).isSameAs(orig);
    }

    @Test
    public void testUnwrap() throws Throwable {
        Connection mock = mock(Connection.class);
        when(mock.unwrap(String.class)).thenReturn("called");

        ConnectionProxyLogic logic = getProxyLogic(mock);

        // run
        Method method = Connection.class.getMethod("unwrap", Class.class);
        Object result = logic.invoke(mock, method, new Object[]{String.class});

        verify(mock).unwrap(String.class);
        assertThat(result).isEqualTo("called");
    }

    @Test
    public void testIsWrapperFor() throws Throwable {
        Connection mock = mock(Connection.class);
        when(mock.isWrapperFor(String.class)).thenReturn(true);

        ConnectionProxyLogic logic = getProxyLogic(mock);

        // run
        Method method = Connection.class.getMethod("isWrapperFor", Class.class);
        Object result = logic.invoke(mock, method, new Object[]{String.class});

        verify(mock).isWrapperFor(String.class);
        assertThat(result).isEqualTo(true);
    }

    @Test
    public void testToString() throws Throwable {
        Connection conn = mock(Connection.class);

        when(conn.toString()).thenReturn("my conn");
        ConnectionProxyLogic logic = getProxyLogic(conn);

        Method method = Object.class.getMethod("toString");
        Object result = logic.invoke(conn, method, null);

        assertThat(result).isEqualTo(conn.getClass().getSimpleName() + " [my conn]");
    }

    @Test
    public void testHashCode() throws Throwable {
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);

        Method method = Object.class.getMethod("hashCode");
        Object result = logic.invoke(conn, method, null);

        assertThat(result).isEqualTo(conn.hashCode());
    }

    @Test
    public void testEquals() throws Throwable {
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);

        Method method = Object.class.getMethod("equals", Object.class);

        // equals(null)
        Object result = logic.invoke(conn, method, new Object[]{null});
        assertThat(result).isEqualTo(false);

        // equals(true)
        result = logic.invoke(conn, method, new Object[]{conn});
        assertThat(result).isEqualTo(true);
    }

    @Test
    public void methodExecutionListener() throws Throwable {
        CallCheckMethodExecutionListener listener = new CallCheckMethodExecutionListener();
        ProxyConfig proxyConfig = ProxyConfig.Builder.create().methodListener(listener).build();
        ConnectionInfo connectionInfo = new ConnectionInfo();

        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = new ConnectionProxyLogic(conn, connectionInfo, proxyConfig);

        Method method = Connection.class.getMethod("createStatement");
        logic.invoke(conn, method, new Object[]{});

        assertTrue(listener.isBeforeMethodCalled());
        assertTrue(listener.isAfterMethodCalled());

        MethodExecutionContext executionContext = listener.getAfterMethodContext();
        assertSame("method should come from interface",
                Connection.class, executionContext.getMethod().getDeclaringClass());
        assertSame("createStatement", executionContext.getMethod().getName());
        assertSame(conn, executionContext.getTarget());
        assertSame(connectionInfo, executionContext.getConnectionInfo());
    }

    @Test
    public void close() throws Throwable {
        final AtomicBoolean isClosedBefore = new AtomicBoolean();
        final AtomicBoolean isClosedAfter = new AtomicBoolean();
        final AtomicBoolean isClosedBeforeCalled = new AtomicBoolean();
        final AtomicBoolean isClosedAfterCalled = new AtomicBoolean();

        MethodExecutionListener listener = new MethodExecutionListener() {
            @Override
            public void beforeMethod(MethodExecutionContext executionContext) {
                isClosedBefore.set(executionContext.getConnectionInfo().isClosed());
                isClosedBeforeCalled.set(true);
            }

            @Override
            public void afterMethod(MethodExecutionContext executionContext) {
                isClosedAfter.set(executionContext.getConnectionInfo().isClosed());
                isClosedAfterCalled.set(true);
            }
        };
        ProxyConfig proxyConfig = ProxyConfig.Builder.create().methodListener(listener).build();
        ConnectionInfo connectionInfo = new ConnectionInfo();

        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = new ConnectionProxyLogic(conn, connectionInfo, proxyConfig);

        Method method = Connection.class.getMethod("close");

        assertThat(isClosedBefore).isFalse();
        assertThat(isClosedBeforeCalled).isFalse();
        assertThat(isClosedAfter).isFalse();
        assertThat(isClosedAfterCalled).isFalse();

        logic.invoke(conn, method, null);

        assertThat(isClosedBefore).isFalse();
        assertThat(isClosedBeforeCalled).isTrue();
        assertThat(isClosedAfter).isTrue();
        assertThat(isClosedAfterCalled).isTrue();
    }

    @Test
    public void commitAndRollbackCount() throws Throwable {

        ProxyConfig proxyConfig = ProxyConfig.Builder.create().build();
        ConnectionInfo connectionInfo = new ConnectionInfo();

        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = new ConnectionProxyLogic(conn, connectionInfo, proxyConfig);

        Method commitMethod = Connection.class.getMethod("commit");
        Method rollbackMethod = Connection.class.getMethod("rollback");

        assertThat(connectionInfo.getCommitCount()).isEqualTo(0);
        assertThat(connectionInfo.getRollbackCount()).isEqualTo(0);

        logic.invoke(conn, commitMethod, null);
        assertThat(connectionInfo.getCommitCount()).isEqualTo(1);
        assertThat(connectionInfo.getRollbackCount()).isEqualTo(0);

        logic.invoke(conn, commitMethod, null);
        assertThat(connectionInfo.getCommitCount()).isEqualTo(2);
        assertThat(connectionInfo.getRollbackCount()).isEqualTo(0);

        logic.invoke(conn, rollbackMethod, null);
        assertThat(connectionInfo.getCommitCount()).isEqualTo(2);
        assertThat(connectionInfo.getRollbackCount()).isEqualTo(1);

        logic.invoke(conn, rollbackMethod, null);
        assertThat(connectionInfo.getCommitCount()).isEqualTo(2);
        assertThat(connectionInfo.getRollbackCount()).isEqualTo(2);
    }

}
